from enum import Enum
from abc import ABC, abstractmethod
from functools import total_ordering

Category = Enum("Category", ("Dog", "Cat", "Lion", "Tiger"))


class Animal(ABC):
    def __init__(self, name: str, category: Category):
        self.name = name
        self.category = category

    @abstractmethod
    def make_sound(self) -> str:
        """All animals must make sound."""
        pass


@total_ordering
class Dog(Animal):
    def __eq__(self, other: object) -> bool:
        return isinstance(other, Dog) and (self.name.lower(), self.category) == (
            other.name.lower(),
            other.category,
        )

    def __lt__(self, other: object) -> bool:
        if not isinstance(other, Dog):
            return NotImplemented
        if self.category != other.category:
            return NotImplemented
        return self.name.lower() < other.name.lower()

    def __hash__(self) -> int:
        return hash((self.name.lower(), self.category))

    def __repr__(self) -> str:
        return f"Dog(name={self.name!r}, category={self.category!r})"

    def make_sound(self) -> str:
        return "Woof!"


# Notes

# Python calls other.__gt__(dog1) if dog1.__lt__(other) returns NotImplemented.
# Important: the operands are swapped in the reflected call.

# Important details

# The reflected method is always the “opposite” operator:
# | Operator | Reflected Method |
# | -------- | ---------------- |
# | `<`      | `__gt__`         |
# | `<=`     | `__ge__`         |
# | `>`      | `__lt__`         |
# | `>=`     | `__le__`         |
# | `==`     | `__eq__`         |
# | `!=`     | `__ne__`         |


# Python only calls the reflected method if the left-hand side returns NotImplemented, not if it returns False.

# Let’s map out all six comparison operators for your Dog class so you can see exactly how they behave, including the interplay with NotImplemented and total_ordering.
# | Operator | Method called                                            |
# | -------- | -------------------------------------------------------- |
# | `<`      | `__lt__`                                                 |
# | `<=`     | generated by `total_ordering` → uses `__lt__` + `__eq__` |
# | `>`      | generated → `not (self <= other)`                        |
# | `>=`     | generated → `not (self < other)`                         |
# | `==`     | `__eq__`                                                 |
# | `!=`     | generated → `not (self == other)`                        |

# 2️⃣ Flow of < for Dog objects
# dog1 < dog2
#    |
#    v
# dog1.__lt__(dog2)
#    |
#    +-- if dog2 is not a Dog → returns NotImplemented
#    |       |
#    |       v
#    |   dog2.__gt__(dog1)
#    |       |
#    |       v
#    |   if still NotImplemented → TypeError
#    |
#    +-- if dog2 is a Dog but categories differ → NotImplemented → same reflected logic
#    |
#    +-- else compare names: dog1.name.lower() < dog2.name.lower()


# 3️⃣ Flow for <= (generated by total_ordering)
# dog1 <= dog2
#    |
#    v
# self.__lt__(other) or self.__eq__(other)
#    |
#    +-- if __lt__ or __eq__ returns NotImplemented → Python tries reflected methods
# This ensures that <= is fully consistent with < and ==.


# 4️⃣ Flow for > (generated)
# dog1 > dog2
#    |
#    v
# not (dog1 <= dog2)
# Uses the <= logic internally.
# Any NotImplemented returned by <= propagates upward.


# 5️⃣ Flow for >= (generated)
# dog1 >= dog2
#    |
#    v
# not (dog1 < dog2)
# Uses < logic internally.
# Again, NotImplemented propagates if the objects are incompatible.

# 6️⃣ Flow for == and !=
# dog1 == dog2
#    |
#    v
# dog1.__eq__(dog2)
#    |
#    +-- if dog2 is not Dog → returns False
#    +-- else compares (name.lower(), category)

# dog1 != dog2
#    |
#    v
# not (dog1 == dog2)

# ✅ Key takeaways
#     1. < / > / <= / >= are type-checked first using isinstance and category checks.
#     2. total_ordering generates <=, >, >=, != from your __lt__ and __eq__.
#     3. NotImplemented ensures that comparisons with incompatible types don’t silently return True/False   but allow Python to try reflected operations or raise TypeError.
#     4. == / != are consistent with < / <= / > / >= because you included category in equality and < respects it via NotImplemented.
#     5. Sorting (sorted()) will be stable and respect natural ordering by name.
